/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  Contract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import { TypedEventFilter, TypedEvent, TypedListener } from "./commons";

interface IStakeManagerInterface extends ethers.utils.Interface {
  functions: {
    "stakeForAddress(address,uint256)": FunctionFragment;
    "unlockStake(address)": FunctionFragment;
    "withdrawStake(address)": FunctionFragment;
    "authorizeHubByOwner(address,address)": FunctionFragment;
    "authorizeHubByManager(address)": FunctionFragment;
    "unauthorizeHubByOwner(address,address)": FunctionFragment;
    "unauthorizeHubByManager(address)": FunctionFragment;
    "isRelayManagerStaked(address,address,uint256,uint256)": FunctionFragment;
    "penalizeRelayManager(address,address,uint256)": FunctionFragment;
    "getStakeInfo(address)": FunctionFragment;
    "versionSM()": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "stakeForAddress",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "unlockStake", values: [string]): string;
  encodeFunctionData(
    functionFragment: "withdrawStake",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "authorizeHubByOwner",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "authorizeHubByManager",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "unauthorizeHubByOwner",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "unauthorizeHubByManager",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "isRelayManagerStaked",
    values: [string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "penalizeRelayManager",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getStakeInfo",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "versionSM", values?: undefined): string;

  decodeFunctionResult(
    functionFragment: "stakeForAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unlockStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "authorizeHubByOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "authorizeHubByManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unauthorizeHubByOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unauthorizeHubByManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isRelayManagerStaked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "penalizeRelayManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStakeInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "versionSM", data: BytesLike): Result;

  events: {
    "HubAuthorized(address,address)": EventFragment;
    "HubUnauthorized(address,address,uint256)": EventFragment;
    "StakeAdded(address,address,uint256,uint256)": EventFragment;
    "StakePenalized(address,address,uint256)": EventFragment;
    "StakeUnlocked(address,address,uint256)": EventFragment;
    "StakeWithdrawn(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "HubAuthorized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HubUnauthorized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakeAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakePenalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakeUnlocked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakeWithdrawn"): EventFragment;
}

export class IStakeManager extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: IStakeManagerInterface;

  functions: {
    /**
     * Put a stake for a relayManager and set its unstake delay. If the entry does not exist, it is created, and the caller of this function becomes its owner. If the entry already exists, only the owner can call this function.
     * @param relayManager - address that represents a stake entry and controls relay registrations on relay hubs
     * @param unstakeDelay - number of blocks to elapse before the owner can retrieve the stake after calling 'unlock'
     */
    stakeForAddress(
      relayManager: string,
      unstakeDelay: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Put a stake for a relayManager and set its unstake delay. If the entry does not exist, it is created, and the caller of this function becomes its owner. If the entry already exists, only the owner can call this function.
     * @param relayManager - address that represents a stake entry and controls relay registrations on relay hubs
     * @param unstakeDelay - number of blocks to elapse before the owner can retrieve the stake after calling 'unlock'
     */
    "stakeForAddress(address,uint256)"(
      relayManager: string,
      unstakeDelay: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    unlockStake(
      relayManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "unlockStake(address)"(
      relayManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    withdrawStake(
      relayManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "withdrawStake(address)"(
      relayManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    authorizeHubByOwner(
      relayManager: string,
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "authorizeHubByOwner(address,address)"(
      relayManager: string,
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    authorizeHubByManager(
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "authorizeHubByManager(address)"(
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    unauthorizeHubByOwner(
      relayManager: string,
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "unauthorizeHubByOwner(address,address)"(
      relayManager: string,
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    unauthorizeHubByManager(
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "unauthorizeHubByManager(address)"(
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    isRelayManagerStaked(
      relayManager: string,
      relayHub: string,
      minAmount: BigNumberish,
      minUnstakeDelay: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    "isRelayManagerStaked(address,address,uint256,uint256)"(
      relayManager: string,
      relayHub: string,
      minAmount: BigNumberish,
      minUnstakeDelay: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Slash the stake of the relay relayManager. In order to prevent stake kidnapping, burns half of stake on the way.
     * @param amount - amount to withdraw from stake
     * @param beneficiary - address that receives half of the penalty amount
     * @param relayManager - entry to penalize
     */
    penalizeRelayManager(
      relayManager: string,
      beneficiary: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Slash the stake of the relay relayManager. In order to prevent stake kidnapping, burns half of stake on the way.
     * @param amount - amount to withdraw from stake
     * @param beneficiary - address that receives half of the penalty amount
     * @param relayManager - entry to penalize
     */
    "penalizeRelayManager(address,address,uint256)"(
      relayManager: string,
      beneficiary: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getStakeInfo(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<
      [
        [BigNumber, BigNumber, BigNumber, string] & {
          stake: BigNumber;
          unstakeDelay: BigNumber;
          withdrawBlock: BigNumber;
          owner: string;
        }
      ] & {
        stakeInfo: [BigNumber, BigNumber, BigNumber, string] & {
          stake: BigNumber;
          unstakeDelay: BigNumber;
          withdrawBlock: BigNumber;
          owner: string;
        };
      }
    >;

    "getStakeInfo(address)"(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<
      [
        [BigNumber, BigNumber, BigNumber, string] & {
          stake: BigNumber;
          unstakeDelay: BigNumber;
          withdrawBlock: BigNumber;
          owner: string;
        }
      ] & {
        stakeInfo: [BigNumber, BigNumber, BigNumber, string] & {
          stake: BigNumber;
          unstakeDelay: BigNumber;
          withdrawBlock: BigNumber;
          owner: string;
        };
      }
    >;

    versionSM(overrides?: CallOverrides): Promise<[string]>;

    "versionSM()"(overrides?: CallOverrides): Promise<[string]>;
  };

  /**
   * Put a stake for a relayManager and set its unstake delay. If the entry does not exist, it is created, and the caller of this function becomes its owner. If the entry already exists, only the owner can call this function.
   * @param relayManager - address that represents a stake entry and controls relay registrations on relay hubs
   * @param unstakeDelay - number of blocks to elapse before the owner can retrieve the stake after calling 'unlock'
   */
  stakeForAddress(
    relayManager: string,
    unstakeDelay: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Put a stake for a relayManager and set its unstake delay. If the entry does not exist, it is created, and the caller of this function becomes its owner. If the entry already exists, only the owner can call this function.
   * @param relayManager - address that represents a stake entry and controls relay registrations on relay hubs
   * @param unstakeDelay - number of blocks to elapse before the owner can retrieve the stake after calling 'unlock'
   */
  "stakeForAddress(address,uint256)"(
    relayManager: string,
    unstakeDelay: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  unlockStake(
    relayManager: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "unlockStake(address)"(
    relayManager: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  withdrawStake(
    relayManager: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "withdrawStake(address)"(
    relayManager: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  authorizeHubByOwner(
    relayManager: string,
    relayHub: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "authorizeHubByOwner(address,address)"(
    relayManager: string,
    relayHub: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  authorizeHubByManager(
    relayHub: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "authorizeHubByManager(address)"(
    relayHub: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  unauthorizeHubByOwner(
    relayManager: string,
    relayHub: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "unauthorizeHubByOwner(address,address)"(
    relayManager: string,
    relayHub: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  unauthorizeHubByManager(
    relayHub: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "unauthorizeHubByManager(address)"(
    relayHub: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  isRelayManagerStaked(
    relayManager: string,
    relayHub: string,
    minAmount: BigNumberish,
    minUnstakeDelay: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  "isRelayManagerStaked(address,address,uint256,uint256)"(
    relayManager: string,
    relayHub: string,
    minAmount: BigNumberish,
    minUnstakeDelay: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Slash the stake of the relay relayManager. In order to prevent stake kidnapping, burns half of stake on the way.
   * @param amount - amount to withdraw from stake
   * @param beneficiary - address that receives half of the penalty amount
   * @param relayManager - entry to penalize
   */
  penalizeRelayManager(
    relayManager: string,
    beneficiary: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Slash the stake of the relay relayManager. In order to prevent stake kidnapping, burns half of stake on the way.
   * @param amount - amount to withdraw from stake
   * @param beneficiary - address that receives half of the penalty amount
   * @param relayManager - entry to penalize
   */
  "penalizeRelayManager(address,address,uint256)"(
    relayManager: string,
    beneficiary: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getStakeInfo(
    relayManager: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, string] & {
      stake: BigNumber;
      unstakeDelay: BigNumber;
      withdrawBlock: BigNumber;
      owner: string;
    }
  >;

  "getStakeInfo(address)"(
    relayManager: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, string] & {
      stake: BigNumber;
      unstakeDelay: BigNumber;
      withdrawBlock: BigNumber;
      owner: string;
    }
  >;

  versionSM(overrides?: CallOverrides): Promise<string>;

  "versionSM()"(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    /**
     * Put a stake for a relayManager and set its unstake delay. If the entry does not exist, it is created, and the caller of this function becomes its owner. If the entry already exists, only the owner can call this function.
     * @param relayManager - address that represents a stake entry and controls relay registrations on relay hubs
     * @param unstakeDelay - number of blocks to elapse before the owner can retrieve the stake after calling 'unlock'
     */
    stakeForAddress(
      relayManager: string,
      unstakeDelay: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Put a stake for a relayManager and set its unstake delay. If the entry does not exist, it is created, and the caller of this function becomes its owner. If the entry already exists, only the owner can call this function.
     * @param relayManager - address that represents a stake entry and controls relay registrations on relay hubs
     * @param unstakeDelay - number of blocks to elapse before the owner can retrieve the stake after calling 'unlock'
     */
    "stakeForAddress(address,uint256)"(
      relayManager: string,
      unstakeDelay: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    unlockStake(relayManager: string, overrides?: CallOverrides): Promise<void>;

    "unlockStake(address)"(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawStake(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "withdrawStake(address)"(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<void>;

    authorizeHubByOwner(
      relayManager: string,
      relayHub: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "authorizeHubByOwner(address,address)"(
      relayManager: string,
      relayHub: string,
      overrides?: CallOverrides
    ): Promise<void>;

    authorizeHubByManager(
      relayHub: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "authorizeHubByManager(address)"(
      relayHub: string,
      overrides?: CallOverrides
    ): Promise<void>;

    unauthorizeHubByOwner(
      relayManager: string,
      relayHub: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "unauthorizeHubByOwner(address,address)"(
      relayManager: string,
      relayHub: string,
      overrides?: CallOverrides
    ): Promise<void>;

    unauthorizeHubByManager(
      relayHub: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "unauthorizeHubByManager(address)"(
      relayHub: string,
      overrides?: CallOverrides
    ): Promise<void>;

    isRelayManagerStaked(
      relayManager: string,
      relayHub: string,
      minAmount: BigNumberish,
      minUnstakeDelay: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "isRelayManagerStaked(address,address,uint256,uint256)"(
      relayManager: string,
      relayHub: string,
      minAmount: BigNumberish,
      minUnstakeDelay: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Slash the stake of the relay relayManager. In order to prevent stake kidnapping, burns half of stake on the way.
     * @param amount - amount to withdraw from stake
     * @param beneficiary - address that receives half of the penalty amount
     * @param relayManager - entry to penalize
     */
    penalizeRelayManager(
      relayManager: string,
      beneficiary: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Slash the stake of the relay relayManager. In order to prevent stake kidnapping, burns half of stake on the way.
     * @param amount - amount to withdraw from stake
     * @param beneficiary - address that receives half of the penalty amount
     * @param relayManager - entry to penalize
     */
    "penalizeRelayManager(address,address,uint256)"(
      relayManager: string,
      beneficiary: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    getStakeInfo(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, string] & {
        stake: BigNumber;
        unstakeDelay: BigNumber;
        withdrawBlock: BigNumber;
        owner: string;
      }
    >;

    "getStakeInfo(address)"(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, string] & {
        stake: BigNumber;
        unstakeDelay: BigNumber;
        withdrawBlock: BigNumber;
        owner: string;
      }
    >;

    versionSM(overrides?: CallOverrides): Promise<string>;

    "versionSM()"(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    HubAuthorized(
      relayManager: string | null,
      relayHub: string | null
    ): TypedEventFilter<
      [string, string],
      { relayManager: string; relayHub: string }
    >;

    HubUnauthorized(
      relayManager: string | null,
      relayHub: string | null,
      removalBlock: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { relayManager: string; relayHub: string; removalBlock: BigNumber }
    >;

    StakeAdded(
      relayManager: string | null,
      owner: string | null,
      stake: null,
      unstakeDelay: null
    ): TypedEventFilter<
      [string, string, BigNumber, BigNumber],
      {
        relayManager: string;
        owner: string;
        stake: BigNumber;
        unstakeDelay: BigNumber;
      }
    >;

    StakePenalized(
      relayManager: string | null,
      beneficiary: string | null,
      reward: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { relayManager: string; beneficiary: string; reward: BigNumber }
    >;

    StakeUnlocked(
      relayManager: string | null,
      owner: string | null,
      withdrawBlock: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { relayManager: string; owner: string; withdrawBlock: BigNumber }
    >;

    StakeWithdrawn(
      relayManager: string | null,
      owner: string | null,
      amount: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { relayManager: string; owner: string; amount: BigNumber }
    >;
  };

  estimateGas: {
    /**
     * Put a stake for a relayManager and set its unstake delay. If the entry does not exist, it is created, and the caller of this function becomes its owner. If the entry already exists, only the owner can call this function.
     * @param relayManager - address that represents a stake entry and controls relay registrations on relay hubs
     * @param unstakeDelay - number of blocks to elapse before the owner can retrieve the stake after calling 'unlock'
     */
    stakeForAddress(
      relayManager: string,
      unstakeDelay: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Put a stake for a relayManager and set its unstake delay. If the entry does not exist, it is created, and the caller of this function becomes its owner. If the entry already exists, only the owner can call this function.
     * @param relayManager - address that represents a stake entry and controls relay registrations on relay hubs
     * @param unstakeDelay - number of blocks to elapse before the owner can retrieve the stake after calling 'unlock'
     */
    "stakeForAddress(address,uint256)"(
      relayManager: string,
      unstakeDelay: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    unlockStake(
      relayManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "unlockStake(address)"(
      relayManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    withdrawStake(
      relayManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "withdrawStake(address)"(
      relayManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    authorizeHubByOwner(
      relayManager: string,
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "authorizeHubByOwner(address,address)"(
      relayManager: string,
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    authorizeHubByManager(
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "authorizeHubByManager(address)"(
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    unauthorizeHubByOwner(
      relayManager: string,
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "unauthorizeHubByOwner(address,address)"(
      relayManager: string,
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    unauthorizeHubByManager(
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "unauthorizeHubByManager(address)"(
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    isRelayManagerStaked(
      relayManager: string,
      relayHub: string,
      minAmount: BigNumberish,
      minUnstakeDelay: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "isRelayManagerStaked(address,address,uint256,uint256)"(
      relayManager: string,
      relayHub: string,
      minAmount: BigNumberish,
      minUnstakeDelay: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Slash the stake of the relay relayManager. In order to prevent stake kidnapping, burns half of stake on the way.
     * @param amount - amount to withdraw from stake
     * @param beneficiary - address that receives half of the penalty amount
     * @param relayManager - entry to penalize
     */
    penalizeRelayManager(
      relayManager: string,
      beneficiary: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Slash the stake of the relay relayManager. In order to prevent stake kidnapping, burns half of stake on the way.
     * @param amount - amount to withdraw from stake
     * @param beneficiary - address that receives half of the penalty amount
     * @param relayManager - entry to penalize
     */
    "penalizeRelayManager(address,address,uint256)"(
      relayManager: string,
      beneficiary: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getStakeInfo(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getStakeInfo(address)"(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    versionSM(overrides?: CallOverrides): Promise<BigNumber>;

    "versionSM()"(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Put a stake for a relayManager and set its unstake delay. If the entry does not exist, it is created, and the caller of this function becomes its owner. If the entry already exists, only the owner can call this function.
     * @param relayManager - address that represents a stake entry and controls relay registrations on relay hubs
     * @param unstakeDelay - number of blocks to elapse before the owner can retrieve the stake after calling 'unlock'
     */
    stakeForAddress(
      relayManager: string,
      unstakeDelay: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Put a stake for a relayManager and set its unstake delay. If the entry does not exist, it is created, and the caller of this function becomes its owner. If the entry already exists, only the owner can call this function.
     * @param relayManager - address that represents a stake entry and controls relay registrations on relay hubs
     * @param unstakeDelay - number of blocks to elapse before the owner can retrieve the stake after calling 'unlock'
     */
    "stakeForAddress(address,uint256)"(
      relayManager: string,
      unstakeDelay: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    unlockStake(
      relayManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "unlockStake(address)"(
      relayManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    withdrawStake(
      relayManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "withdrawStake(address)"(
      relayManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    authorizeHubByOwner(
      relayManager: string,
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "authorizeHubByOwner(address,address)"(
      relayManager: string,
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    authorizeHubByManager(
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "authorizeHubByManager(address)"(
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    unauthorizeHubByOwner(
      relayManager: string,
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "unauthorizeHubByOwner(address,address)"(
      relayManager: string,
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    unauthorizeHubByManager(
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "unauthorizeHubByManager(address)"(
      relayHub: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    isRelayManagerStaked(
      relayManager: string,
      relayHub: string,
      minAmount: BigNumberish,
      minUnstakeDelay: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "isRelayManagerStaked(address,address,uint256,uint256)"(
      relayManager: string,
      relayHub: string,
      minAmount: BigNumberish,
      minUnstakeDelay: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Slash the stake of the relay relayManager. In order to prevent stake kidnapping, burns half of stake on the way.
     * @param amount - amount to withdraw from stake
     * @param beneficiary - address that receives half of the penalty amount
     * @param relayManager - entry to penalize
     */
    penalizeRelayManager(
      relayManager: string,
      beneficiary: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Slash the stake of the relay relayManager. In order to prevent stake kidnapping, burns half of stake on the way.
     * @param amount - amount to withdraw from stake
     * @param beneficiary - address that receives half of the penalty amount
     * @param relayManager - entry to penalize
     */
    "penalizeRelayManager(address,address,uint256)"(
      relayManager: string,
      beneficiary: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getStakeInfo(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getStakeInfo(address)"(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    versionSM(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "versionSM()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
