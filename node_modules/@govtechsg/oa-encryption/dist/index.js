"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decryptString = exports.encryptString = exports.decodeDocument = exports.encodeDocument = exports.generateEncryptionKey = exports.ENCRYPTION_PARAMETERS = void 0;

var _nodeForge = _interopRequireDefault(require("node-forge"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Default options from responses here
 * https://crypto.stackexchange.com/questions/26783/ciphertext-and-tag-size-and-iv-transmission-with-aes-in-gcm-mode/26787
 */
const ENCRYPTION_PARAMETERS = {
  algorithm: "AES-GCM",
  keyLength: 256,
  // Key length in bits
  ivLength: 96,
  // IV length in bits: NIST suggests 12 bytes
  tagLength: 128,
  // GCM authentication tag length in bits, see link above for explanation
  version: "OPEN-ATTESTATION-TYPE-1" // Type 1 using the above params without compression

};
/**
 * Generates a random key represented as a hexadecimal string
 * @param {number} keyLengthInBits Key length
 */

exports.ENCRYPTION_PARAMETERS = ENCRYPTION_PARAMETERS;

const generateEncryptionKey = (keyLengthInBits = ENCRYPTION_PARAMETERS.keyLength) => {
  const encryptionKey = _nodeForge.default.random.getBytesSync(keyLengthInBits / 8);

  return _nodeForge.default.util.bytesToHex(encryptionKey);
};
/**
 * Generates a initialisation vector represented as a base64 string
 * @param {integer} ivLengthInBits Key length
 */


exports.generateEncryptionKey = generateEncryptionKey;

const generateIv = (ivLengthInBits = ENCRYPTION_PARAMETERS.ivLength) => {
  const iv = _nodeForge.default.random.getBytesSync(ivLengthInBits / 8);

  return _nodeForge.default.util.encode64(iv);
};
/**
 * Generates the requisite randomised variables and initialises the cipher with them
 * @returns the cipher object, encryption key in hex, and iv in base64
 */


const makeCipher = (encryptionKey = generateEncryptionKey()) => {
  const iv = generateIv();

  const cipher = _nodeForge.default.cipher.createCipher(ENCRYPTION_PARAMETERS.algorithm, _nodeForge.default.util.hexToBytes(encryptionKey));

  cipher.start({
    iv: _nodeForge.default.util.decode64(iv),
    tagLength: ENCRYPTION_PARAMETERS.tagLength
  });
  return {
    cipher,
    encryptionKey,
    iv
  };
};

const encodeDocument = document => {
  const bytes = _nodeForge.default.util.encodeUtf8(document);

  return _nodeForge.default.util.encode64(bytes);
};

exports.encodeDocument = encodeDocument;

const decodeDocument = encoded => {
  const decoded = _nodeForge.default.util.decode64(encoded);

  return _nodeForge.default.util.decodeUtf8(decoded);
};

exports.decodeDocument = decodeDocument;

/**
 * Encrypts a given string with symmetric AES
 * @param {string} document Input string to encrypt
 * @returns cipherText cipher text in base64
 * @returns iv iv in base64
 * @returns tag authenticated encryption tag in base64
 * @returns key encryption key in hexadecimal
 * @returns type The encryption algorithm identifier
 */
const encryptString = (document, key) => {
  if (typeof document !== "string") {
    throw new Error("encryptString only accepts strings");
  }

  const _makeCipher = makeCipher(key),
        cipher = _makeCipher.cipher,
        encryptionKey = _makeCipher.encryptionKey,
        iv = _makeCipher.iv;

  const buffer = _nodeForge.default.util.createBuffer(encodeDocument(document));

  cipher.update(buffer);
  cipher.finish();

  const encryptedMessage = _nodeForge.default.util.encode64(cipher.output.data);

  const tag = _nodeForge.default.util.encode64(cipher.mode.tag.data);

  return {
    cipherText: encryptedMessage,
    iv,
    tag,
    key: encryptionKey,
    type: ENCRYPTION_PARAMETERS.version
  };
};
/**
 * Decrypts a given ciphertext along with its associated variables
 * @param {string} cipherText cipher text base64 encoded
 * @param {string} tag aes authentication tag base64 encoded
 * @param {string} iv iv base64 encoded
 * @param {string} key decryption key hexademical encoded
 * @param {string} type encryption algorithm identifier
 */


exports.encryptString = encryptString;

const decryptString = ({
  cipherText,
  tag,
  iv,
  key,
  type
}) => {
  if (type !== ENCRYPTION_PARAMETERS.version) {
    throw new Error(`Expecting version ${ENCRYPTION_PARAMETERS.version} but got ${type}`);
  }

  const keyBytestring = _nodeForge.default.util.hexToBytes(key);

  const cipherTextBytestring = _nodeForge.default.util.decode64(cipherText);

  const ivBytestring = _nodeForge.default.util.decode64(iv);

  const tagBytestring = _nodeForge.default.util.decode64(tag);

  const decipher = _nodeForge.default.cipher.createDecipher("AES-GCM", keyBytestring);

  decipher.start({
    iv: ivBytestring,
    tagLength: ENCRYPTION_PARAMETERS.tagLength,
    tag: _nodeForge.default.util.createBuffer(tagBytestring, "raw")
  });
  decipher.update(_nodeForge.default.util.createBuffer(cipherTextBytestring, "raw"));
  const success = decipher.finish();

  if (!success) {
    throw new Error("Error decrypting message");
  }

  return decodeDocument(decipher.output.data);
};

exports.decryptString = decryptString;